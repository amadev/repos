#!/usr/bin/env joker
;; #-*- mode: clojure; target-shell-session: "shell-joker" -*-

(ns script
  (:require [joker.tools.cli :as cli])
  (:require [joker.os :as os])
  (:require [joker.string :as str])
  (:require [src.repos.core :as r]))

(defn parse-headers
  [headers]
  (when headers
    (into {} (map #(str/split % #":") (str/split-lines headers)))))

(defn parse-tags
  [v]
  (let [v (keyword v)]
   (when-not (#{:shallow :auto-commit} v)
     (throw (ex-info "Invalid tag" {:cause "Tag should be shallow or auto-commit"})))
   [v]))

(def *program* "repos")
(def *version* [0 1 0])
(def *actions*
  [["pull" "Clone or update all specified repositories"]
   ["add" "Add a new repo to DB"]
   ["list" "Show structure of repositories"]
   ["search" "Seacrh for text in group of repositories"]
   ["sync" "Pull and then push repositories"]
   ["gerrit" "Generate db file for repos from Gerrit API"]
   ["add-group" "Add a new repository group"]])
(def *opts*
  [["-v" "--verbose" :default 0 :update-fn inc]
   ["-h" "--help" "Show this summary"]
   ["-p" "--path" "New repository clone path" :required true]
   ["-g" "--group" "Group name allows to filter repository list" :required true]
   [nil "--headers" "Additional headers for the gerrit command if authentication required"
    :required true :parse-fn parse-headers]
   ["-n" "--name" "Repository name" :required true]
   ["-t" "--tags" "Repository tag" :required true :parse-fn parse-tags]
   [nil "--parent" "Parent group name" :required true]])

(defn usage
  [summary errors]
  (printf "usage: %s [options] action\n" *program*)
  (printf "ACTIONS\n\n")
  (doseq [action *actions*]
    (printf "  %s\t\t%s\n" (first action) (second action)))
  (println)
  (printf "OPTIONS\n\n")
  (println summary)
  (when errors
    (println "\nErrors:")
    (run! println errors)))

(let [[args _ rest-args] (partition-by #(= % "--") *command-line-args*)
      {:keys [options arguments summary errors]} (cli/parse-opts args *opts*)
      options (assoc options :rest-args rest-args)
      {:keys [verbose help]} options]
  (when (<= 2 verbose)
    (println "parsed args, options:" arguments options))
  (cond
    errors
    (do
      (usage summary errors)
      (os/exit -1))

    help
    (usage summary nil)

    (and (not (empty? arguments))
         ((set (map first *actions*)) (first arguments)))
    (try
      (r/main arguments options)
      (catch Error e
        (if (ex-message e)
          (printf "Error: %s\nCause: %s\nTry verbose for details\n"
                  (ex-message e)
                  (:cause (ex-data e)))
          (printf "Error: %s\n" e))
        (os/exit 1)))

    :else
    (do
      (usage summary ["Must specify one available action"])
      (os/exit -1))))

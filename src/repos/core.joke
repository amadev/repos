;; #-*- mode: clojure -*-

;; Local Variables:
;; target-shell-session: "shell-joker"
;; End:

(ns src.repos.core
  (:require [joker.os :as os])
  (:require [joker.yaml :as yaml])
  (:require [joker.string :as str])
  (:require [joker.time :as time]))

(def *context* {})

(declare ex)

(defn dir?
  [path]
  (try
    (:dir? (os/stat path))
    (catch Error e
      false)))

(defn index
  [i v]
  (ffirst (filter #(= (second %) i) (map-indexed vector v))))

(defn write
  [path string]
  ;; todo: didn't find the proper way to do it on joker
  (ex "bash" "-c" (format "echo '%s' >> %s" string path)))

(defn log
  [message level]
  (let [levels [:debug :info :error]]
    (when (>= (index level levels) (index (:log_level *context*) levels))
      (println (format "[%s] %s %s"
                       (apply str (-> level str str/upper-case rest))
                       (time/format (time/now) time/rfc3339)
                       message)))))

;; todo: generate log funcs dynamically
(defn debug
  [message & args]
  (log (apply str (interpose " " (cons message args))) :debug))

(defn info
  [message & args]
  (log (apply str (interpose " " (cons message args))) :info))

(defn error
  [message & args]
  (log (apply str (interpose " " (cons message args))) :error))

(defn ex
  [& args]
  (let [args (filter (complement empty?) args)
        s-args (str/join " " args)]
    (debug "call:" s-args)
    (let [r (os/exec (first args) {:args (rest args)})]
      (debug "result:" r)
      (when-not (:success r)
        (throw (ex-info "Exec failed"
                        {:cause (:err r)}))))))

(defmacro in-dir
  [dir & body]
  `(let [save-dir# (os/cwd)]
     (os/chdir ~dir)
     ~@body
     (os/chdir save-dir#)))

(defn pull
  [repo]
  (if (not (dir? (:path repo)))
    ;; clone
    (let [shallow (contains? (:tags repo) :shallow)]
      (ex "git" "clone"
          (if shallow "--depth 1" "")
          (format "--origin=%s" (-> repo :remotes first :name))
          (format "--branch=%s" (-> repo :branches first :name))
          (-> repo :remotes first :url)
          (:path repo))
      (in-dir (:path repo)
              (doseq [r (rest (:remotes repo))]
                (do
                  (ex "git" "remote" "add" (:name r) (:url r))
                  (ex "git" "fetch" (:name r))))
              (doseq [b (rest (:branches repo))]
                (ex "git" "checkout" "-b" (:name b) "--track" (format "%s/%s" (:remote b) (:refspec b)))))
      ;; todo: add group processing
      ;; (os/exec "mkdir -p group_path; ln -s repo_path group_path/repo_name")
      )
    ;; pull
    (in-dir
     (:path repo)
     (doseq [b (:branches repo)]
       (ex "git" "checkout" (:name b))
       (ex "git" "pull" "--rebase" (:remote b) (:refspec b))))))

(defn struct-walk
  [data key-func val-func & [path]]
  (cond
    (or (list? data) (vector? data)) (mapv #(struct-walk %1 key-func val-func (apply str [path ".[]"])) data)
    (map? data) (into {} (for [[k v] data] [(key-func k) (struct-walk v key-func val-func (apply str [path "." k]))]))
    :else (val-func data path)))

(defn expand-env
  [env data]
  ;; the func would be much easier if str/replace could suport repl arg as func
  (loop [replaces (map #(list %1 (get env (apply str (rest %1)) "")) (re-seq #"\$[A-Z0-9_]+" data))
         s data]
    (if (empty? replaces)
      s
      (let [pair (first replaces)
            from (first pair)
            to (second pair)]
        (recur (rest replaces) (str/replace s from to))))))

(defn process-yaml-values
  [v p]
  (if (str/ends-with? p "tags.[]")
    (keyword v)
    (expand-env (os/env) v)))

(defn read-yaml
  [path]
  (let [data (yaml/read-string (slurp path))]
    (struct-walk data keyword process-yaml-values)))

(defn pull-all
  [repos]
  (doseq [r repos]
    (info "pull" (:name r))
    (pull r)))

(defn main
  []
  (let [env (os/env)
        db-path (get env "REPOS_DB" "$HOME/.repos/db.yaml")
        db (read-yaml (expand-env (os/env) db-path))]
    (binding [*context* {:log_level :debug}]
      (pull-all (:repos db)))))

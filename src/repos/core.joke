;; #-*- mode: clojure; target-shell-session: "shell-joker" -*-

(ns src.repos.core
  (:require [joker.os :as os])
  (:require [joker.yaml :as yaml])
  (:require [joker.string :as str])
  (:require [joker.time :as time])
  (:require [joker.filepath :as filepath]))

(def *context* {})
(def *levels* [:debug :info :error])

(declare debug)
(declare ex)

;; === utils ===

(defn dir?
  [path]
  (try
    (:dir? (os/stat path))
    (catch Error e
      false)))

(defmacro in-dir
  [dir & body]
  `(let [save-dir# (os/cwd)]
     (os/chdir ~dir)
     ~@body
     (os/chdir save-dir#)))

(defn index
  [i v]
  (ffirst (filter #(= (second %) i) (map-indexed vector v))))

(defn ex
  [& args]
  (let [args (filter (complement empty?) args)
        s-args (str/join " " args)]
    (debug "call:" s-args)
    (let [r (os/exec (first args) {:args (rest args)})]
      (debug "result:" r)
      (when-not (:success r)
        (throw (ex-info "Exec failed"
                        {:cause (:err r)})))
      r
      )))

(defn walk
  ;; todo: recur
  [data key-func val-func & [path]]
  (cond
    (or (list? data) (vector? data))
    (mapv #(walk %1 key-func val-func (apply str [path ".[]"])) data)
    (map? data)
    (into {} (for [[k v] data] [(key-func k) (walk v key-func val-func (apply str [path "." k]))]))
    :else
    (val-func data path)))

(defn expand-env
  [s]
  ;; the func would be much easier if str/replace could suport repl arg as func
  ;; todo: joker issue
  (loop [replaces (map #(list %1 (get (:env *context*) (apply str (rest %1)) "")) (re-seq #"\$[A-Z0-9_]+" s))
         s s]
    (if (empty? replaces)
      s
      (let [pair (first replaces)
            from (first pair)
            to (second pair)]
        (recur (rest replaces) (str/replace s from to))))))

(defn process-yaml-value
  [v p]
  (if (str/ends-with? p "tags.[]")
    (keyword v)
    (expand-env v)))

(defn prepare-value-for-yaml
  [v p]
  (if (str/ends-with? p "tags.[]") (name v) v))

(defn read-yaml
  [path]
  (let [data (yaml/read-string (slurp path))]
    (walk data keyword process-yaml-value)))

(defn indent
  [n]
  (apply str (take (* n 2) (repeat " "))))

(defn serialize
  ;; todo: recur
  [data & [level]]
  (let [level (or level 0)]
   (cond
     (or (vector? data) (list? data))
     (doseq [v data]
       (if (or (map? v) (vector? v) (list? v))
         (do
           (printf "%s-\n" (indent level))
           (serialize v (inc level)))
         (printf "%s- %s\n" (indent level) v)))
     (map? data)
     (doseq [[k v] data]
       (if (and (not (empty? v)) (or (map? v) (vector? v) (list? v)))
         (do
           (printf "%s%s:\n" (indent level) k)
           (serialize v (inc level)))
         (printf "%s%s: %s\n" (indent level) k (str v))))
     :else (printf "%s%s\n" (indent level) data))))

(defn write-yaml
  [data & [path]]
  (let [data (walk data name prepare-value-for-yaml)
        s (with-out-str (serialize data))]
    (if path (spit path s) s)))

;; === logs ===

(defn write
  [path string]
  ;; todo: didn't find the proper way to append string to file in joker
  (ex "bash" "-c" (format "echo '%s' >> %s" string path)))

(defn log
  [message level]
  (when (>= (index level *levels*) (index (:log_level *context* :debug) *levels*))
    (println (format "[%s] %s %s"
                     (apply str (-> level str str/upper-case rest))
                     (time/format (time/now) time/rfc3339)
                     message))))

;; todo: generate log funcs dynamically
(defn debug
  [message & args]
  (log (apply str (interpose " " (cons message args))) :debug))

(defn info
  [message & args]
  (log (apply str (interpose " " (cons message args))) :info))

(defn error
  [message & args]
  (log (apply str (interpose " " (cons message args))) :error))

;; === logic ===

(defn reload-branches
  [repo]
  (in-dir (:path repo)
          (doseq [r (rest (:remotes repo))]
            (do
              (try
                (ex "git" "remote" "add" (:name r) (:url r))
                (catch Error e
                  (when-not (str/index-of (:cause (ex-data e)) "already exists")
                    (throw (ex-info (ex-message e) (ex-data e))))))
              (ex "git" "fetch" (:name r))))
          (doseq [b (rest (:branches repo))]
            (try
              (ex "git" "checkout" "-b" (:name b) "--track" (format "%s/%s" (:remote b) (:refspec b)))
              (catch Error e
                (when-not (str/index-of (:cause (ex-data e)) "already exists")
                  (throw (ex-info (ex-message e) (ex-data e)))))))))

(defn pull
  [repo]
  (if (not (dir? (:path repo)))
    ;; clone
    (ex "git" "clone"
        (if (some #(= % :shallow) (:tags repo)) "--depth=1" "")
        (format "--origin=%s" (-> repo :remotes first :name))
        (format "--branch=%s" (-> repo :branches first :name))
        (-> repo :remotes first :url)
        (:path repo))
    ;; pull
    (in-dir
     (:path repo)
     (reload-branches repo)
     (doseq [b (:branches repo)]
       (ex "git" "checkout" (:name b))
       (ex "git" "pull" "--rebase" (:remote b) (:refspec b))))))

(defn pull-all
  [repos]
  (doseq [r repos]
    (info "pull" (:name r))
    (pull r)))

(defn repo
  ([url] (repo url {}))
  ([url options]
   (let [name (or (:name options) (joker.filepath/base url))
         path (or (:path options) (expand-env (format "$HOME/src/%s" name)))]
    (info "add a repo" name "to" path)
    {:name name
     :path path
     ;; todo: get default group from context
     :group (or (:group options) "root")
     :tags []
     :remotes [{:name "origin"
                :url url}]
     :branches [{:name "master"
                 :remote "origin"
                 :refspec "master"}]})))

(defn add-repo
  [db path url options]
  (write-yaml
   (assoc db :repos (conj (:repos db) (repo url options)))
   path))

(defn get-group-path
  [group groups]
  (let [group-dict (into {} (for [g groups] [(:name g) (:parent g)]))]
    (loop [group group
           result []]
      (if (not (= :not-exists (get group-dict group :not-exists)))
        (if (not (group-dict group))
          (str/join "/" (reverse (conj result group)))
          (recur (group-dict group) (conj result group)))))))

(defn put-repos-into-groups
  [repos groups dir]
  (doseq [r repos]
    (let [group-path (get-group-path (:group r) groups)]
      (when-not group-path
        (throw (ex-info (format "Not found path for group %s" (:group r))
                        {:cause "Probably group hierarchy is defined incorrectly"})))
      (let [group-path-full (filepath/join dir group-path)
            repo-target-path (filepath/join group-path-full (:name r))]
        (ex "mkdir" "-p" group-path-full)
        (ex "rm" "-f" repo-target-path)
        (ex "ln" "-s" (:path r) repo-target-path)))))

(defn repo-list
  [dir]
  (when (dir? dir)
    (in-dir dir
            (println (:out (ex "bash" "-c" "find . | sed -e 's/[^-][^\\/]*\\// |/g' -e 's/|\\([^ ]\\)/|-\\1/'"))))))

(defn search
  [command search-string dir args]
  (in-dir
   dir
   (let [ex-args (concat (str/split command #" ") [search-string dir] args)]
     (try
       (println (:out (apply ex ex-args)))
       (catch Error e
         (if (empty? (:cause (ex-data e)))
           (throw (ex-info "Nothing found" (assoc (ex-data e) :cause "Search command exit code -1")))
           (throw (ex-info (ex-message e) (ex-data e)))))))))

(defn main
  [args options]
  (binding [*context* {:log_level (get (vec (reverse *levels*)) (:verbose options) :debug)
                       :env (os/env)}]
    (let [config-path (expand-env (get (:env *context*) "REPOS_CONFIG" "$HOME/.repos/config.yaml"))
          config (read-yaml config-path)
          db-path (:db config)
          db (read-yaml db-path)
          groups-dir (:groups config)
          current-group (filepath/join groups-dir (str (get-group-path (:group options) (:groups db))))]
      (debug "db-path" db-path)
      (debug "current-group" current-group)
      ;; to allow group conf update via DB file it's issued everytime
      ;; group tree in file system corresponds to config always
      ;; some link to repo may be broken due to repo is not pulled yet
      ;; groups withot repo in it will not be created
      (put-repos-into-groups (:repos db) (:groups db) groups-dir)
      (case (first args)
        "pull" (pull-all (:repos db))
        ;; todo: check agrs number for each action
        "add" (add-repo db db-path (second args) options)
        "list" (repo-list current-group)
        "search" (search (:search_command config) (second args) current-group (:rest-args options)))
      )))

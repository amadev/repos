;; #-*- mode: clojure -*-

;; Local Variables:
;; target-shell-session: "shell-joker"
;; End:

(ns src.repos.core
  (:require [joker.os :as os])
  (:require [joker.yaml :as yaml])
  (:require [joker.string :as str]))

(defn dir?
  [path]
  (try
    (:dir? (os/stat path))
    (catch Error e
      false)))

(defn ex
  [& args]
  (let [args (filter (complement empty?) args)]
    (prn "call: " args)
    (prn "result:" (os/exec (first args) {:args (rest args)}))))

(defmacro in-dir
  [dir & body]
  `(let [save-dir# (os/cwd)]
     (os/chdir ~dir)
     ~@body
     (os/chdir save-dir#)))

(defn pull
  [repo]
  (if (not (dir? (:path repo)))
    ;; clone
    (let [shallow (contains? (:tags repo) :shallow)]
      (ex "git" "clone"
          (if shallow "--depth 1" "")
          (format "--origin=%s" (-> repo :remotes first :name))
          (format "--branch=%s" (-> repo :branches first :name))
          (-> repo :remotes first :url)
          (:path repo))
      (in-dir (:path repo)
       (doseq [r (rest (:remotes repo))]
         (do
           (ex "git" "remote" "add" (:name r) (:url r))
           (ex "git" "fetch" (:name r))))
       (doseq [b (rest (:branches repo))]
         (ex "git" "checkout" "-b" (:name b) "--track" (format "%s/%s" (:remote b) (:refspec b)))))
      ;; todo add group processing
      ;; (os/exec "mkdir -p group_path; ln -s repo_path group_path/repo_name")
      )
    ;; pull
    (in-dir
     (:path repo)
     (doseq [b (:branches repo)]
       (ex "git" "checkout" (:name b))
       (ex "git" "pull" "--rebase" (:remote b) (:refspec b))))))

(defn struct-walk
  [data key-func val-func & [path]]
  (cond
    (or (list? data) (vector? data)) (mapv #(struct-walk %1 key-func val-func (apply str [path ".[]"])) data)
    (map? data) (into {} (for [[k v] data] [(key-func k) (struct-walk v key-func val-func (apply str [path "." k]))]))
    :else (val-func data path)))

(defn expand-env
  [env data]
  ;; the func would be much easier if str/replace could suport repl arg as func
  (loop [replaces (map #(list %1 (get env (apply str (rest %1)) "")) (re-seq #"\$[A-Z0-9_]+" data))
         s data]
    (if (empty? replaces)
      s
      (let [pair (first replaces)
            from (first pair)
            to (second pair)]
        (recur (rest replaces) (str/replace s from to))))))

(defn process-yaml-values
  [v p]
  (if (str/ends-with? p "tags.[]")
    (keyword v)
    (expand-env (os/env) v)))

(defn read-yaml
  [path]
  (let [data (yaml/read-string (slurp path))]
    (struct-walk data keyword process-yaml-values)))

(defn pull-all
  [repos]
  (doseq [r repos]
    (pull r)))

;; #-*- mode: clojure; target-shell-session: "shell-joker" -*-

(ns src.repos.core
  (:require [joker.os :as os])
  (:require [joker.yaml :as yaml])
  (:require [joker.string :as str])
  (:require [joker.time :as time]))

(def *context* {})
(def *levels* [:debug :info :error])

(declare ex)

(defn dir?
  [path]
  (try
    (:dir? (os/stat path))
    (catch Error e
      false)))

(defn index
  [i v]
  (ffirst (filter #(= (second %) i) (map-indexed vector v))))

(defn write
  [path string]
  ;; todo: didn't find the proper way to do it on joker
  (ex "bash" "-c" (format "echo '%s' >> %s" string path)))

(defn log
  [message level]
  (when (>= (index level *levels*) (index (:log_level *context*) *levels*))
    (println (format "[%s] %s %s"
                     (apply str (-> level str str/upper-case rest))
                     (time/format (time/now) time/rfc3339)
                     message))))

;; todo: generate log funcs dynamically
(defn debug
  [message & args]
  (log (apply str (interpose " " (cons message args))) :debug))

(defn info
  [message & args]
  (log (apply str (interpose " " (cons message args))) :info))

(defn error
  [message & args]
  (log (apply str (interpose " " (cons message args))) :error))

(defn ex
  [& args]
  (let [args (filter (complement empty?) args)
        s-args (str/join " " args)]
    (debug "call:" s-args)
    (let [r (os/exec (first args) {:args (rest args)})]
      (debug "result:" r)
      (when-not (:success r)
        (throw (ex-info "Exec failed"
                        {:cause (:err r)}))))))

(defmacro in-dir
  [dir & body]
  `(let [save-dir# (os/cwd)]
     (os/chdir ~dir)
     ~@body
     (os/chdir save-dir#)))

(defn reload-branches
  [repo]
  (in-dir (:path repo)
          (doseq [r (rest (:remotes repo))]
            (do
              (try
                (ex "git" "remote" "add" (:name r) (:url r))
                (catch Error e
                  (when-not (str/index-of (:cause (ex-data e)) "already exists")
                    (throw (ex-info (ex-message e) (ex-data e))))))
              (ex "git" "fetch" (:name r))))
          (doseq [b (rest (:branches repo))]
            (try
              (ex "git" "checkout" "-b" (:name b) "--track" (format "%s/%s" (:remote b) (:refspec b)))
              (catch Error e
                (when-not (str/index-of (:cause (ex-data e)) "already exists")
                  (throw (ex-info (ex-message e) (ex-data e)))))))))

(defn pull
  [repo]
  (if (not (dir? (:path repo)))
    ;; clone
    (let [shallow (contains? (:tags repo) :shallow)]
      (ex "git" "clone"
          (if shallow "--depth 1" "")
          (format "--origin=%s" (-> repo :remotes first :name))
          (format "--branch=%s" (-> repo :branches first :name))
          (-> repo :remotes first :url)
          (:path repo))
      (reload-branches repo)
      ;; todo: add group processing
      ;; (os/exec "mkdir -p group_path; ln -s repo_path group_path/repo_name")
      )
    ;; pull
    (in-dir
     (:path repo)
     (reload-branches repo)
     (doseq [b (:branches repo)]
       (ex "git" "checkout" (:name b))
       (ex "git" "pull" "--rebase" (:remote b) (:refspec b))))))

(defn struct-walk
  ;; todo: recur
  [data key-func val-func & [path]]
  (cond
    (or (list? data) (vector? data)) (mapv #(struct-walk %1 key-func val-func (apply str [path ".[]"])) data)
    (map? data) (into {} (for [[k v] data] [(key-func k) (struct-walk v key-func val-func (apply str [path "." k]))]))
    :else (val-func data path)))

(defn expand-env
  [env data]
  ;; the func would be much easier if str/replace could suport repl arg as func
  ;; todo: joker issue
  (loop [replaces (map #(list %1 (get env (apply str (rest %1)) "")) (re-seq #"\$[A-Z0-9_]+" data))
         s data]
    (if (empty? replaces)
      s
      (let [pair (first replaces)
            from (first pair)
            to (second pair)]
        (recur (rest replaces) (str/replace s from to))))))

(defn process-yaml-value
  [v p]
  (if (str/ends-with? p "tags.[]")
    (keyword v)
    (expand-env (os/env) v)))

(defn prepare-value-for-yaml
  [v p]
  (if (str/ends-with? p "tags.[]")
    (if (keyword? v) (apply str (rest (str v))) v)
    v))

(defn prepare-key-for-yaml
  [k]
  (if ( "tags.[]")
    (if (keyword? v) (apply str (rest (str v))) v)
    v))

(defn read-yaml
  [path]
  (let [data (yaml/read-string (slurp path))]
    (struct-walk data keyword process-yaml-value)))

(defn pull-all
  [repos]
  (doseq [r repos]
    (info "pull" (:name r))
    (pull r)))

(defn indent
  [n]
  (apply str (take (* n 2) (repeat " "))))

(defn serialize
  ;; todo: recur
  [data & [level]]
  (let [level (or level 0)]
   (cond
     (or (vector? data) (list? data))
     (doseq [v data]
       (if (or (map? v) (vector? v) (list? v))
         (do
           (printf "%s-\n" (indent level))
           (serialize v (inc level)))
         (printf "%s- %s\n" (indent level) v)))
     (map? data)
     (doseq [[k v] data]
       (if (and (not (empty? v)) (or (map? v) (vector? v) (list? v)))
         (do
           (printf "%s%s:\n" (indent level) k)
           (serialize v (inc level)))
         (printf "%s%s: %s\n" (indent level) k (str v))))
     :else (printf "%s%s\n" (indent level) data))))

(defn write-yaml
  [data & [path]]
  (let [data (struct-walk
              data
              #(if (keyword? %) (apply str (rest (str %))) %)
              prepare-value-for-yaml)
        s (with-out-str (serialize data))]
    (if path
      (spit path s)
      s)))

(defn repo
  [url & {:keys [name group]}]
  {:name (or name (joker.filepath/base url))
   :group (or group "__default__")
   :tags []
   :remotes {:name "origin"
             :url url}
   :branches {:name "master"
              :remote "origin"
              :refspec "master"}})

(defn main
  [action options]
  (let [env (os/env)
        db-path (get env "REPOS_DB" "$HOME/.repos/db.yaml")
        db (read-yaml (expand-env (os/env) db-path))]
    (binding [*context* {:log_level (get (vec (reverse *levels*)) (:verbose options) :debug)}]
      (case action
        "pull" (pull-all (:repos db))))))
